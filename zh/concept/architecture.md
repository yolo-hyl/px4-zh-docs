# PX4 架构概览

PX4由两个主要层级组成：[飞行堆栈](#flight-stack)是一个估计与飞行控制系统，[中间件](#middleware)则是一个通用机器人层级，可支持任何类型的自主机器人，提供内部/外部通信和硬件集成。

所有PX4 [机体](../airframes/index.md)共享单一代码库（这包括其他机器人系统，如船只、探测器、潜水器等）。整个系统设计是[响应式](http://www.reactivemanifesto.org)，这意味着：

- 所有功能均被划分为可替换、可复用的组件
- 通信通过异步消息传递完成
- 系统可处理不同的工作负载

<a id="architecture"></a>## 高级软件架构

下图详细概述了 PX4 的构建模块。  
图的上半部分包含中间件模块，下半部分显示了飞行栈的组件。

![PX4 架构](../../assets/diagrams/PX4_Architecture.svg)

<!-- 该图可以从  
[这里](https://drive.google.com/file/d/0B1TDW9ajamYkaGx3R0xGb1NaeU0/view?usp=sharing)  
更新，并通过 draw.io Diagrams 打开。如果没有 px4.io Google 账户，可能需要请求访问权限。  
注意：导出后部分箭头可能错误。此时需放大图形直到箭头正确，再重新导出。 -->

源代码被分割为独立的模块/程序（图中以 `monospace` 显示）。  
通常一个构建模块对应一个模块。

:::tip
在运行时，您可以通过 shell 中的 `top` 命令查看正在执行的模块，每个模块可通过 `<module_name> start/stop` 单独启动/停止。  
虽然 `top` 命令专用于 NuttX shell，但其他命令也可在 SITL shell（pxh>）中使用。  
有关每个模块的更多信息，请参见[模块与命令参考](../modules/modules_main.md)。
:::

箭头显示了模块之间最重要的连接信息流。  
实际上，连接比图中显示的更多，且部分数据（如参数）被大多数模块访问。

模块通过名为 [uORB](../middleware/uorb.md) 的发布-订阅消息总线进行通信。  
发布-订阅机制意味着：

- 系统具有响应性——异步运行，新数据可用时立即更新
- 所有操作和通信完全并行化
- 系统组件可通过线程安全方式从任意位置获取数据

::: info
此架构允许每个模块在运行时快速且轻松地被替换。
:::

### 飞行栈

飞行栈是用于自主无人机的制导、导航和控制算法集合。  
包含固定翼、多旋翼和 VTOL 机体的控制器，以及姿态和位置估计算法。

下图概述了飞行栈的构建模块。  
它包含从传感器、遥控输入和自主飞行控制（导航器）到电机或舵机控制（执行器）的完整流程。

![PX4 高级飞行栈](../../assets/diagrams/PX4_High-Level_Flight-Stack.svg)

<!-- 该图可以从  
[这里](https://drive.google.com/a/px4.io/file/d/15J0eCL77fHbItA249epT3i2iOx4VwJGI/view?usp=sharing)  
更新，并通过 draw.io Diagrams 打开。如果没有 px4.io Google 账户，可能需要请求访问权限。  
注意：导出后部分箭头可能错误。此时需放大图形直到箭头正确，再重新导出。 -->

**估计器**接收一个或多个传感器输入，进行融合并计算机体状态（例如从 IMU 传感器数据计算姿态）。

**控制器**是一个接收设定值和测量值或估计状态（过程变量）的组件。  
其目标是通过调整过程变量使其匹配设定值。  
输出是达到设定值的修正值。  
例如位置控制器接收位置设定值作为输入，过程变量是当前估计的位置，输出是使机体朝目标位置移动的姿态和推力设定值。

**混合器**接收力指令（如“向右转”）并将其转换为单个电机指令，同时确保不超过某些限制。  
这种转换因机体类型而异，取决于多种因素，如电机相对于重心的布局或机体的旋转惯性。

<a id="middleware"></a>

### 中间件

[中间件](../middleware/index.md) 主要由嵌入式传感器驱动程序、与外部世界通信（伴飞计算机、地面站等）以及 uORB 发布-订阅消息总线组成。

此外，中间件包含一个[仿真层](../simulation/index.md)，允许 PX4 飞行代码在桌面操作系统上运行，并在模拟的“世界”中控制虚拟机体。

## 更新速率

由于模块等待消息更新，通常由驱动定义模块的更新速度。
大多数IMU驱动以1kHz对数据进行采样，整合后以250Hz发布。
系统其他部分如导航器(navigator)不需要这么高的更新速率，因此运行速度明显更慢。

可通过运行`uorb top`实时检查系统中的消息更新速率，详情可参考[inspected](../middleware/uorb.md)

<a id="runtime-environment"></a>## 运行环境

PX4 运行在提供 POSIX-API 的多种操作系统上（如 Linux、macOS、NuttX 或 QuRT）。系统应具备某种形式的实时调度（例如 FIFO）。

模块间通信（通过 [uORB](../middleware/uorb.md)）基于共享内存。整个 PX4 中间件运行在单一地址空间中，即所有模块共享内存。

::: info
系统设计允许通过较小的改动使每个模块运行在独立的地址空间（需要修改的部分包括 `uORB`、`parameter interface`、`dataman` 和 `perf`）。
:::

模块有 2 种不同的执行方式：

- **任务**：模块在自己的任务中运行，拥有独立的堆栈和进程优先级。
- **工作队列任务**：模块在共享工作队列上运行，与其他队列任务共享相同的堆栈和工作队列线程优先级。

  - 所有任务必须以协作方式运行，因为它们无法相互中断。
  - 多个 _工作队列任务_ 可以运行在同一个队列上，且可以存在多个队列。
  - 通过指定未来固定时间或 uORB 话题更新回调来调度 _工作队列任务_。

  在工作队列上运行模块的优势是占用更少的 RAM，且可能减少任务切换次数。缺点是 _工作队列任务_ 不允许睡眠、等待消息或执行阻塞 IO（例如文件读取）。长时间运行的任务（执行繁重计算）应运行在独立任务中或至少在独立工作队列中。

::: info
运行在工作队列上的任务不会显示在 [`top`](../modules/modules_command.md#top) 中（仅工作队列本身可见，例如显示为 `wq:lp_default`）。使用 [`work_queue status`](../modules/modules_system.md#work-queue) 可查看所有活跃的工作队列项。
:::

### 后台任务

`px4_task_spawn_cmd()` 用于启动与调用任务（父任务）独立运行的新任务（NuttX）或线程（POSIX - Linux/macOS）：

```cpp
independent_task = px4_task_spawn_cmd(
    "commander",                    // 进程名称
    SCHED_DEFAULT,                  // 调度类型（RR 或 FIFO）
    SCHED_PRIORITY_DEFAULT + 40,    // 调度优先级
    3600,                           // 新任务或线程的堆栈大小
    commander_thread_main,          // 任务（或线程）的主函数
    (char * const *)&argv[0]        // 传递给新任务的 void 指针
                                    // （此处为命令行参数）。
    );
```

### 操作系统特定信息

#### NuttX

[NuttX](https://nuttx.apache.org//) 是 PX4 在飞控板上运行的主要实时操作系统。它开源（BSD 许可证），轻量级、高效且非常稳定。

模块以任务形式运行：它们拥有自己的文件描述符列表，但共享单一地址空间。一个任务仍可启动一个或多个共享文件描述符列表的线程。

每个任务/线程具有固定大小的堆栈，并存在一个周期性任务，通过堆栈着色检查所有堆栈是否保留足够的空闲空间。

#### Linux/macOS

在 Linux 或 macOS 上，PX4 运行在单一进程中，所有模块运行在自己的线程中（与 NuttX 的任务和线程区分方式不同）。